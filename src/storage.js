// src/storage.js

/**
 * @fileoverview Manages IndexedDB operations for WebX Journal.
 * Handles database creation, versioning, and CRUD operations for user profiles
 * and journal entries.
 */

import { displayMessage } from './utils.js'; // For displaying messages

// Database constants
const DB_NAME = 'WebXJournalDB';
export const DB_VERSION = 1; // Increment this when schema changes

// Object Store Names
const USER_PROFILES_STORE = 'userProfiles';
const JOURNAL_ENTRIES_STORE = 'journalEntries';

let db = null; // Variable to hold the IndexedDB instance

/**
 * Initializes the IndexedDB database.
 * Creates object stores if they don't exist or upgrades them on version change.
 * @returns {Promise<IDBDatabase>} A Promise that resolves with the database instance.
 */
export function initializeIndexedDB() {
    return new Promise((resolve, reject) => {
        if (db) {
            console.log('IndexedDB already initialized.');
            return resolve(db);
        }

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            console.log(`IndexedDB upgrade needed. Old version: ${event.oldVersion}, New version: ${event.newVersion}`);

            // Create userProfiles object store
            if (!db.objectStoreNames.contains(USER_PROFILES_STORE)) {
                console.log(`Creating object store: ${USER_PROFILES_STORE}`);
                db.createObjectStore(USER_PROFILES_STORE, { keyPath: 'username' });
            }

            // Create journalEntries object store
            if (!db.objectStoreNames.contains(JOURNAL_ENTRIES_STORE)) {
                console.log(`Creating object store: ${JOURNAL_ENTRIES_STORE}`);
                // 'id' is a unique identifier generated by the app
                // 'timestamp' can be used for indexing and sorting
                const journalStore = db.createObjectStore(JOURNAL_ENTRIES_STORE, { keyPath: 'id' });
                journalStore.createIndex('timestamp', 'timestamp', { unique: false });
                // If you later add a user ID to entries for multi-user support:
                // journalStore.createIndex('userId', 'userId', { unique: false });
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            console.log('IndexedDB opened successfully.');
            db.onversionchange = () => {
                db.close();
                displayMessage('Database is outdated, please reload the page.', 'text-yellow-400 bg-yellow-800');
                console.warn('Database version changed. Closing connection.');
            };
            resolve(db);
        };

        request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            displayMessage(`Database error: ${event.target.error.message}`, 'text-red-400 bg-red-800');
            reject(event.target.error);
        };
    });
}

/**
 * Gets a transaction for one or more object stores.
 * @param {string|string[]} storeNames The name(s) of the object store(s) to access.
 * @param {IDBTransactionMode} mode The transaction mode ('readonly' or 'readwrite').
 * @returns {IDBTransaction} The IndexedDB transaction object.
 */
function getTransaction(storeNames, mode) {
    if (!db) {
        throw new Error('IndexedDB not initialized. Call initializeIndexedDB first.');
    }
    return db.transaction(storeNames, mode);
}

// --- User Profile Operations ---

/**
 * Saves a user profile to IndexedDB.
 * @param {object} profile The user profile object to save. Must contain 'username' as keyPath.
 * @returns {Promise<void>} A Promise that resolves when the profile is saved.
 */
export function saveUserProfile(profile) {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(USER_PROFILES_STORE, 'readwrite');
        const store = transaction.objectStore(USER_PROFILES_STORE);
        const request = store.put(profile); // 'put' for add or update

        request.onsuccess = () => {
            console.log(`User profile for ${profile.username} saved.`);
            resolve();
        };

        request.onerror = (event) => {
            console.error('Error saving user profile:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during saveUserProfile:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Retrieves a user profile from IndexedDB by username.
 * @param {string} username The username of the profile to retrieve.
 * @returns {Promise<object|undefined>} A Promise that resolves with the user profile object
 * or undefined if not found.
 */
export function getUserProfile(username) {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(USER_PROFILES_STORE, 'readonly');
        const store = transaction.objectStore(USER_PROFILES_STORE);
        const request = store.get(username);

        request.onsuccess = () => {
            console.log(`User profile for ${username} retrieved.`, request.result);
            resolve(request.result);
        };

        request.onerror = (event) => {
            console.error('Error retrieving user profile:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during getUserProfile:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Deletes a user profile from IndexedDB by username.
 * @param {string} username The username of the profile to delete.
 * @returns {Promise<void>} A Promise that resolves when the profile is deleted.
 */
export function deleteUserProfile(username) {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(USER_PROFILES_STORE, 'readwrite');
        const store = transaction.objectStore(USER_PROFILES_STORE);
        const request = store.delete(username);

        request.onsuccess = () => {
            console.log(`User profile for ${username} deleted.`);
            resolve();
        };

        request.onerror = (event) => {
            console.error('Error deleting user profile:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during deleteUserProfile:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Retrieves all keys from the userProfiles store.
 * Useful for checking if any users are registered without fetching full profiles.
 * @returns {Promise<string[]>} A Promise that resolves with an array of usernames.
 */
export function getAllProfileKeys() {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(USER_PROFILES_STORE, 'readonly');
        const store = transaction.objectStore(USER_PROFILES_STORE);
        const request = store.getAllKeys();

        request.onsuccess = () => {
            resolve(request.result);
        };

        request.onerror = (event) => {
            console.error('Error getting all profile keys:', event.target.error);
            reject(event.target.error);
        };
    });
}


// --- Journal Entry Operations ---

/**
 * Saves a journal entry to IndexedDB.
 * @param {object} entry The journal entry object to save. Must contain 'id' as keyPath.
 * @returns {Promise<void>} A Promise that resolves when the entry is saved.
 */
export function saveJournalEntry(entry) {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(JOURNAL_ENTRIES_STORE, 'readwrite');
        const store = transaction.objectStore(JOURNAL_ENTRIES_STORE);
        const request = store.put(entry);

        request.onsuccess = () => {
            console.log(`Journal entry ${entry.id} saved.`);
            resolve();
        };

        request.onerror = (event) => {
            console.error('Error saving journal entry:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during saveJournalEntry:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Retrieves all journal entries from IndexedDB.
 * @returns {Promise<object[]>} A Promise that resolves with an array of journal entry objects.
 */
export function getAllJournalEntries() {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(JOURNAL_ENTRIES_STORE, 'readonly');
        const store = transaction.objectStore(JOURNAL_ENTRIES_STORE);
        const request = store.getAll();

        request.onsuccess = () => {
            console.log('All journal entries retrieved.');
            resolve(request.result);
        };

        request.onerror = (event) => {
            console.error('Error retrieving all journal entries:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during getAllJournalEntries:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Deletes a journal entry from IndexedDB by its ID.
 * @param {string} id The ID of the journal entry to delete.
 * @returns {Promise<void>} A Promise that resolves when the entry is deleted.
 */
export function deleteJournalEntry(id) {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction(JOURNAL_ENTRIES_STORE, 'readwrite');
        const store = transaction.objectStore(JOURNAL_ENTRIES_STORE);
        const request = store.delete(id);

        request.onsuccess = () => {
            console.log(`Journal entry ${id} deleted.`);
            resolve();
        };

        request.onerror = (event) => {
            console.error('Error deleting journal entry:', event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during deleteJournalEntry:', event.target.error);
            reject(event.target.error);
        };
    });
}

/**
 * Clears all data from all object stores. Use with caution!
 * This is primarily for account deletion or a full reset.
 * @returns {Promise<void>} A Promise that resolves when all data is cleared.
 */
export function clearAllData() {
    return new Promise((resolve, reject) => {
        const transaction = getTransaction([USER_PROFILES_STORE, JOURNAL_ENTRIES_STORE], 'readwrite');
        const userStore = transaction.objectStore(USER_PROFILES_STORE);
        const journalStore = transaction.objectStore(JOURNAL_ENTRIES_STORE);

        const userClearRequest = userStore.clear();
        const journalClearRequest = journalStore.clear();

        let userCleared = false;
        let journalCleared = false;

        userClearRequest.onsuccess = () => {
            console.log(`${USER_PROFILES_STORE} cleared.`);
            userCleared = true;
            if (journalCleared) {
                resolve();
            }
        };

        journalClearRequest.onsuccess = () => {
            console.log(`${JOURNAL_ENTRIES_STORE} cleared.`);
            journalCleared = true;
            if (userCleared) {
                resolve();
            }
        };

        userClearRequest.onerror = (event) => {
            console.error(`Error clearing ${USER_PROFILES_STORE}:`, event.target.error);
            reject(event.target.error);
        };

        journalClearRequest.onerror = (event) => {
            console.error(`Error clearing ${JOURNAL_ENTRIES_STORE}:`, event.target.error);
            reject(event.target.error);
        };

        transaction.onerror = (event) => {
            console.error('Transaction error during clearAllData:', event.target.error);
            reject(event.target.error);
        };

        transaction.oncomplete = () => {
            console.log('All object stores cleared successfully.');
            // resolve is already called when both stores are cleared
        };
    });
}

/**
 * Bulk imports journal entries into IndexedDB.
 * This is designed to be used after clearing existing data.
 * @param {Array<object>} entries An array of journal entry objects to import.
 * @returns {Promise<void>} A Promise that resolves when all entries are imported.
 */
export function bulkImportJournalEntries(entries) {
    return new Promise((resolve, reject) => {
        if (entries.length === 0) {
            console.log('No entries to import.');
            return resolve();
        }

        const transaction = getTransaction(JOURNAL_ENTRIES_STORE, 'readwrite');
        const store = transaction.objectStore(JOURNAL_ENTRIES_STORE);

        let completedPuts = 0;
        const totalPuts = entries.length;

        for (const entry of entries) {
            const request = store.put(entry);
            request.onsuccess = () => {
                completedPuts++;
                if (completedPuts === totalPuts) {
                    console.log(`Bulk import of ${totalPuts} journal entries complete.`);
                    resolve();
                }
            };
            request.onerror = (event) => {
                console.error(`Error importing entry ${entry.id}:`, event.target.error);
                // Reject the whole promise on the first error, or handle partial success
                reject(event.target.error);
            };
        }

        transaction.onerror = (event) => {
            console.error('Transaction error during bulkImportJournalEntries:', event.target.error);
            reject(event.target.error);
        };
    });
}
